
/*
 * ws2811.s
 *
 * 
 * Модуль для работы со светодиодными чипами WS2812, а также совместимыми с ними (WS2811, PL9823)
 *
 * Author: Погребняк Дмитрий, г. Самара, 2015
 *
 * Помещённый здесь код является свободным. Т.е. допускается его свободное использование для любых целей,
 * включая коммерческие, при условии указания ссылки на автора (Погребняк Дмитрий, http://aterlux.ru/).
 */ 
#define _SFR_ASM_COMPAT 1
#define __SFR_OFFSET 0
#include "ws2812.h"

.global led_data_init

led_data_init:
  cbi LED_DATA_PORT, LED_DATA
  sbi LED_DATA_DDR, LED_DATA
  #ifdef LED_DATA2
    cbi LED_DATA_PORT, LED_DATA2
    sbi LED_DATA_DDR, LED_DATA2
  #endif
ret

// Пауза 2 такта одной командой. Для уменьшения размера кода
#define nop2 rjmp .+0 

// r18-r25, r26-r27 (X), r30-r31 (Z) можно использовать свободно
// r1 - равен нулю и должен быть обнулён, если изменялся. 
// Остальные (r0, r2-r17, r28-r29(Y) ) - нужно сохранять и восстанавливать.
// Входные параметры: [r25:]r24 - первый параметр,  [r23:]r22 - второй, [r21:]r20 - третий, [r19:]r18 - четвёртый, остальные в стеке
// Результат, если есть в [[r23:r22:]r25:]r24 


#ifndef LED_DATA2 // Если не определён второй вывод, то вывод на одну линейку 

.global led_data_out // Ассемблерная функция должна быть объявлена global


#ifndef LED_DATA_OUT_FAST // Если не определено, то низкоскоростной вывод (20 тактов на бит) на одну линейку

// По спецификации WS2811, низкая скорость:
// - высокий уровень нуля 0.5 мкс = 4 такта
// - низкий уровень нуля 2 мкс = 16 тактов 
// - высокий уровень единицы 1.2 мкс ~= 10 тактов (реализовано 12 тактов, чтобы соответствовать WS2812 @16MHz)
// - низкий уровень единицы 1.3 мкс ~= 10 тактов (реализовано 8 тактов, чтобы соответствовать WS2812 @16MHz)

// Первый параметр r25:r24 - указатель на массив с данными
// второй параметр r23:r22 - количество светодиодов.
led_data_out: 
  // Указатель в X
  movw r26, r24
  // В r25:r24 копируем количество, умноженное на три
  movw r24, r22
  lsl r24
  rol r25
  add r24, r22
  adc r25, r23
  // Теперь в r25:r24 количество байт, которые нужно вывести
  in r20, SREG // Сохранение регистра флагов, в т.ч. флага прерываний
  cli // Запрет прерываний
  // в r22 будет текущий байт
  // в r23 счётчик бит
  loop_slow:
    ld r22, X+ // загружаем очередной байт  (2 такта)
	ldi r23, 8 // загружаем счётчик бит (1 такт)

	bit_loop_slow:
	  sbi LED_DATA_PORT, LED_DATA // Устанавливаем высокий уровень на выходе (2 такта)
	  lsl r22 //  сдвигаем влево байт данных (1 такт)
	  brcs bit_loop_slow_1_skip // Если была вытолкана единица, перескакиваем чемер следующию инструкцию в обход (1 такт - нет перехода, 2 - есть)
	  cbi LED_DATA_PORT, LED_DATA // Устанавливаем низкий уровень на выходе, если у нас нолик (2 такта)
	  nop
	  bit_loop_slow_1_return:
	  dec r23 // уменьшаем r23 (1 такт)
	  breq bit_loop_slow_out // Выход из цикла, если перебрали все биты в байте (2 такта, если переход, иначе 1)
	  nop
	  nop2
	  cbi LED_DATA_PORT, LED_DATA // Устанавливаем низкий уровень на выходе, что бы там ни было (2 такта)
	  nop2 // 4 такта.
	  nop2
	rjmp bit_loop_slow // (2 такта)
	bit_loop_slow_1_skip: rjmp bit_loop_slow_1_return // 2 такта на прыжок. Такой обход нужен, чтобы выровнять количество тактов

    bit_loop_slow_out:
    cbi LED_DATA_PORT, LED_DATA // Устанавливаем низкий уровень на выходе, что бы там ни было (2 такта)
	nop

    sbiw r24, 1 // Уменьшаем на 1  (2 такта)
  brne loop_slow // Крутим, пока не дойдём до нуля (2 такта)

  out SREG, r20 // Восстановление флага прерываний
ret

#else // Если определён LED_DATA_OUT_FAST, то высокоскоростной вывод (10 тактов на бит) на одну линейку

// По спецификации WS2812B
// - высокий уровень нуля 0.4 мкс ~= 3 такта
// - низкий уровень нуля 0.85 мкс ~= 7 тактов
// - высокий уровень единицы 0.8 мкс ~= 7 тактов
// - низкий уровень единицы 0.45 мкс ~= 3 такта

// Первый параметр r25:r24 - указатель на массив с данными
// второй параметр r23:r22 - количество светодиодов.
led_data_out:
  // Указатель в X
  movw r26, r24
  // В r25:r24 копируем количество, умноженное на три
  movw r24, r22
  lsl r24
  rol r25
  add r24, r22
  adc r25, r23
  // Теперь в r25:r24 количество байт, которые нужно вывести
  in r20, SREG // Сохранение регистра флагов, в т.ч. флага прерываний

  cli // Запрет прерываний
  // в r19 - значение выводов всего порта с низким уровнем на линии
  // в r18 - значение выводов всего порта с высоким уровнем на линии
  in r19, LED_DATA_PORT
  cbr r19, (1 << LED_DATA)
  mov r18, r19
  sbr r18, (1 << LED_DATA)

  ld r22, X+ // загружаем первый байт  (2 такта)
  ldi r23, 6 // Первые шесть бит прорабатываем в цикле - экономим флеш

  bit_loop_fast:
    out LED_DATA_PORT, r18
    nop
    sbrs r22, 7
    out LED_DATA_PORT, r19
    lsl r22
    nop
    dec r23
    out LED_DATA_PORT, r19
   brne bit_loop_fast

    nop
    // Два последних бита выводятся вне цикла. В промежутках грузится информация на следующий байт
    out LED_DATA_PORT, r18
    nop
    sbrs r22, 7
    out LED_DATA_PORT, r19
    nop2
    nop
    out LED_DATA_PORT, r19


    sbiw r24, 1 // Уменьшаем на 1  (2 такта) команды ниже до brne не меняют SREG
    out LED_DATA_PORT, r18
    nop
    sbrs r22, 6
    out LED_DATA_PORT, r19
    ldi r23, 6 // Загрузка счётчика бит на следующий цикл
    ld r22, X+ // загружаем очередной байт (2 такта) Последний байт будет загружен за пределами массва - ничего страшного.
    out LED_DATA_PORT, r19
  brne bit_loop_fast // Если не дошли до конца, переходим к битовому циклу циклу

  out SREG, r20 // Восстановление флага прерываний
ret

#endif // LED_DATA_OUT_FAST

#else // Если определён второй вывод, то вывод на две линейки одновременно 

.global led_data_out2 // Ассемблерная функция должна быть объявлена global

#ifndef LED_DATA_OUT_FAST // Если не определено, то низкоскоростной вывод (20 тактов на бит) на две линейки

// По спецификации WS2811, низкая скорость:
// - высокий уровень нуля 0.5 мкс = 4 такта
// - низкий уровень нуля 2 мкс = 16 тактов
// - высокий уровень единицы 1.2 мкс ~= 10 тактов (реализовано 12 тактов, чтобы соответствовать WS2812 @16MHz)
// - низкий уровень единицы 1.3 мкс ~= 10 тактов (реализовано 8 тактов, чтобы соответствовать WS2812 @16MHz)

// Первый параметр r25:r24 - указатель на первый элемент первого массива с данными, 
// второй параметр r23:r22 - указатель на первый элемент второго массива с данными 
// третий параметр r21:r20 - количество светодиодов на каждом выводе
led_data_out2: 
#ifdef LED_DATA2
  // Указатель на первый массив в X
  movw r26, r24
  // Указатель на второй массив в Z
  movw r30, r22
  // В r25:r24 копируем количество, умноженное на три
  movw r24, r20
  lsl r24
  rol r25
  add r24, r20
  adc r25, r21
  // Теперь в r25:r24 количество байт, которые нужно вывести
  in r20, SREG // Сохранение регистра флагов, в т.ч. флага прерываний
  push r20
  cli // Запрет прерываний
  // в r22 будет текущий байт первой линейки
  // в r21 будет текущий байт второй линейки
  // в r23 счётчик бит

  // в r18 - значение выводов всего порта с высоким уровнем на линиях
  // в r19 - значение выводов всего порта с низким уровнем на линиях
  // r20 - значение выводов всего порта с выводимыми уровнями
  in r18, LED_DATA_PORT
  sbr r18, (1 << LED_DATA) | (1 << LED_DATA2)
  mov r19,  r18
  cbr r19, (1 << LED_DATA) | (1 << LED_DATA2)
  mov r20, r18

  ld r22, X+ // загружаем очередной байт  (2 такта)
  ld r21, Z+ // загружаем очередной байт второй линейки (2 такта)
	ldi r23, 7 // загружаем счётчик бит. Первые 7 бит в цикле, остальные - снаружи (1 такт)

	bit_loop_twoway:
    bst r22, 7
    out LED_DATA_PORT, r18
    bld r20, LED_DATA // копирование бита из регистра t в нужную позицию
    bst r21, 7 // сохрание старшего бита в регистр t
    bld r20, LED_DATA2 // копирование бита из регистра t в нужную позицию
    out LED_DATA_PORT, r20
    nop2
    nop2
    nop
    nop2
    out LED_DATA_PORT, r19
    nop
    lsl r22
    lsl r21
	  dec r23 // уменьшаем r23 (1 такт)
	brne bit_loop_twoway // Продолжаем цикл, пока не переберём 7 бит из байта (2 такта, если переход, иначе 1)

  	ldi r23, 7 // загружаем счётчик бит (1 такт)

    // вывод последнего бита из байта, грузим в промежутках всё для следующего байта
    bst r22, 7
    out LED_DATA_PORT, r18
    bld r20, LED_DATA // копирование бита из регистра t в нужную позицию
    bst r21, 7 // сохрание старшего бита в регистр t
    bld r20, LED_DATA2 // копирование бита из регистра t в нужную позицию
    out LED_DATA_PORT, r20
    nop
    sbiw r24, 1 // Уменьшаем на 1  (2 такта)
    breq bit_loop_twoway_end // Выходим, если байты кончились
    nop
    nop2
    out LED_DATA_PORT, r19
    ld r22, X+ // загружаем очередной байт  (2 такта)
    ld r21, Z+ // загружаем очередной байт второй линейки (2 такта)
  rjmp bit_loop_twoway

  bit_loop_twoway_end:
  out LED_DATA_PORT, r19

  pop r20
  out SREG, r20 // Восстановление флага прерываний
#endif
ret

#else // Если определён LED_DATA_OUT_FAST, то высокоскоростной вывод (10 тактов на бит) на две линейки

// По спецификации WS2812B
// - высокий уровень нуля 0.4 мкс ~= 3 такта
// - низкий уровень нуля 0.85 мкс ~= 7 тактов
// - высокий уровень единицы 0.8 мкс ~= 7 тактов
// - низкий уровень единицы 0.45 мкс ~= 3 такта

// Первый параметр r25:r24 - указатель на первый элемент первого массива с данными, 
// второй параметр r23:r22 - указатель на первый элемент второго массива с данными 
// третий параметр r21:r20 - количество светодиодов на каждом выводе
led_data_out2: 
  // Указатель на первый массив в X
  movw r26, r24
  // Указатель на второй массив в Z
  movw r30, r22
  // В r25:r24 копируем количество, умноженное на три
  movw r24, r20
  lsl r24
  rol r25
  add r24, r20
  adc r25, r21
  // Теперь в r25:r24 количество байт, которые нужно вывести
  in r20, SREG // Сохранение регистра флагов, в т.ч. флага прерываний
  cli // Запрет прерываний
  // в r22 будет текущий байт первой линейки
  // в r21 будет текущий байт второй линейки

  // в r18 - значение выводов всего порта с высоким уровнем на линиях
  // в r19 - значение выводов всего порта с низким уровнем на линиях
  // r23 - значение выводов всего порта с выводимыми уровнями
  in r18, LED_DATA_PORT
  sbr r18, (1 << LED_DATA) | (1 << LED_DATA2)
  mov r19,  r18
  cbr r19, (1 << LED_DATA) | (1 << LED_DATA2)
  mov r23, r18

  ld r22, X+ // загружаем очередной байт  (2 такта)
  ld r21, Z+ // загружаем очередной байт второй линейки (2 такта)
  loop_twoway_fast:
    out LED_DATA_PORT, r19

    bst r22, 7
    bld r23, LED_DATA // копирование бита из регистра t в нужную позицию
    out LED_DATA_PORT, r18
    bst r21, 7 // сохрание старшего бита в регистр t
    bld r23, LED_DATA2 // копирование бита из регистра t в нужную позицию
    out LED_DATA_PORT, r23
    nop2 
    nop
    out LED_DATA_PORT, r19

    bst r22, 6
    bld r23, LED_DATA // копирование бита из регистра t в нужную позицию
    out LED_DATA_PORT, r18
    bst r21, 6 // сохрание старшего бита в регистр t
    bld r23, LED_DATA2 // копирование бита из регистра t в нужную позицию
    out LED_DATA_PORT, r23
    nop2
    nop
    out LED_DATA_PORT, r19

    bst r22, 5
    bld r23, LED_DATA // копирование бита из регистра t в нужную позицию
    out LED_DATA_PORT, r18
    bst r21, 5 // сохрание старшего бита в регистр t
    bld r23, LED_DATA2 // копирование бита из регистра t в нужную позицию
    out LED_DATA_PORT, r23
    nop2
    nop
    out LED_DATA_PORT, r19

    bst r22, 4
    bld r23, LED_DATA // копирование бита из регистра t в нужную позицию
    out LED_DATA_PORT, r18
    bst r21, 4 // сохрание старшего бита в регистр t
    bld r23, LED_DATA2 // копирование бита из регистра t в нужную позицию
    out LED_DATA_PORT, r23
    nop2
    nop
    out LED_DATA_PORT, r19

    bst r22, 3
    bld r23, LED_DATA // копирование бита из регистра t в нужную позицию
    out LED_DATA_PORT, r18
    bst r21, 3 // сохрание старшего бита в регистр t
    bld r23, LED_DATA2 // копирование бита из регистра t в нужную позицию
    out LED_DATA_PORT, r23
    nop
    sbiw r24, 1 // Уменьшаем на 1  (2 такта)
    out LED_DATA_PORT, r19

    bst r22, 2
    bld r23, LED_DATA // копирование бита из регистра t в нужную позицию
    out LED_DATA_PORT, r18
    bst r21, 2 // сохрание старшего бита в регистр t
    bld r23, LED_DATA2 // копирование бита из регистра t в нужную позицию
    out LED_DATA_PORT, r23
    breq loop_twoway_fast_exit // Выходим, если байты кончились. bst bld и out не изменяют флагов после sbiw
    bst r22, 1
    out LED_DATA_PORT, r19

    bld r23, LED_DATA // копирование бита из регистра t в нужную позицию
    bst r21, 1 // сохрание старшего бита в регистр t
    out LED_DATA_PORT, r18
    bld r23, LED_DATA2 // копирование бита из регистра t в нужную позицию
    bst r22, 0
    out LED_DATA_PORT, r23
    bld r23, LED_DATA // копирование бита из регистра t в нужную позицию
    bst r21, 0 // сохрание старшего бита в регистр t
    bld r23, LED_DATA2 // копирование бита из регистра t в нужную позицию
    out LED_DATA_PORT, r19

    ld r22, X+ // загружаем очередной байт  (2 такта)
    out LED_DATA_PORT, r18
    ld r21, Z+ // загружаем очередной байт второй линейки (2 такта)
    out LED_DATA_PORT, r23
    nop
  rjmp loop_twoway_fast


  loop_twoway_fast_exit:
  // доделываем последние два бита последнего байта
  out LED_DATA_PORT, r19

  bst r22, 1
  bld r23, LED_DATA // копирование бита из регистра t в нужную позицию
  out LED_DATA_PORT, r18
  bst r21, 1 // сохрание старшего бита в регистр t
  bld r23, LED_DATA2 // копирование бита из регистра t в нужную позицию
  out LED_DATA_PORT, r23
  nop2
  nop
  out LED_DATA_PORT, r19

  bst r22, 0
  bld r23, LED_DATA // копирование бита из регистра t в нужную позицию
  out LED_DATA_PORT, r18
  bst r21, 0 // сохрание старшего бита в регистр t
  bld r23, LED_DATA2 // копирование бита из регистра t в нужную позицию
  out LED_DATA_PORT, r23
  nop2
  nop
  out LED_DATA_PORT, r19

  out SREG, r20 // Восстановление флага прерываний
ret
#endif // LED_DATA_OUT_FAST

#endif // LED_DATA2








